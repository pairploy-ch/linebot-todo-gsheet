const express = require('express');
const line = require('@line/bot-sdk');
const dotenv = require('dotenv');
const schedule = require('node-schedule');

dotenv.config();

const config = {
  channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.CHANNEL_SECRET,
};

const app = express();
const client = new line.Client(config);

// ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• todo list ‡πÅ‡∏•‡∏∞ scheduled jobs
const todoList = new Map(); // userId -> todos[]
const scheduledJobs = new Map(); // todoId -> job

// Todo item structure
class TodoItem {
  constructor(id, userId, task, reminderTime) {
    this.id = id;
    this.userId = userId;
    this.task = task;
    this.reminderTime = reminderTime;
    this.completed = false;
    this.createdAt = new Date();
  }
}

// Generate simple ID (auto-increment per user)
function generateId(userId) {
  const userTodos = todoList.get(userId) || [];
  return (userTodos.length + 1).toString();
}

// Schedule reminder
function scheduleReminder(todoItem) {
  const job = schedule.scheduleJob(todoItem.reminderTime, async () => {
    try {
      const message = {
        type: 'text',
        text: `üîî ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô! -3- ‡∏î‡πà‡∏ß‡∏ô‡πÜ‡πÜ‡πÜ‡πÜ ‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏≥‡∏™‡∏¥‡πà‡∏á‡∏ô‡∏µ‡πâ‡∏£‡∏∂‡∏¢‡∏≤‡∏á‡∏á‡∏á \nüìù ${todoItem.task}\n\nüí° ‡∏û‡∏¥‡∏°‡∏û‡πå "done ${todoItem.id}" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏ß‡πâ‡∏ß`
      };
      
      await client.pushMessage(todoItem.userId, message);
      console.log(`‚úÖ Reminder sent for: ${todoItem.task}`);
    } catch (error) {
      console.error('‚ùå Error sending reminder:', error);
    }
  });
  
  scheduledJobs.set(todoItem.id, job);
}

// Parse date and time
function parseDateTime(dateTimeStr) {
  try {
    // Support formats: "2024-12-25 14:30", "25/12/2024 14:30", "14:30" (today)
    const now = new Date();
    
    if (dateTimeStr.includes(' ')) {
      const [datePart, timePart] = dateTimeStr.split(' ');
      const [hour, minute] = timePart.split(':').map(Number);
      
      let date;
      if (datePart.includes('-')) {
        // Format: YYYY-MM-DD
        const [year, month, day] = datePart.split('-').map(Number);
        date = new Date(year, month - 1, day, hour, minute);
      } else if (datePart.includes('/')) {
        // Format: DD/MM/YYYY
        const [day, month, year] = datePart.split('/').map(Number);
        date = new Date(year, month - 1, day, hour, minute);
      }
      
      return date;
    } else if (dateTimeStr.includes(':')) {
      // Format: HH:MM (today)
      const [hour, minute] = dateTimeStr.split(':').map(Number);
      const date = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, minute);
      
      // If time has passed today, schedule for tomorrow
      if (date < now) {
        date.setDate(date.getDate() + 1);
      }
      
      return date;
    }
    
    return null;
  } catch (error) {
    return null;
  }
}

// Format date for display
function formatDate(date) {
  const options = {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
    hour: '2-digit',
    minute: '2-digit',
    timeZone: 'Asia/Bangkok'
  };
  return date.toLocaleString('th-TH', options);
}

// LINE SDK middleware
app.use('/webhook', line.middleware(config));
app.use(express.json());

// Logging middleware
app.use((req, res, next) => {
  console.log(`${new Date().toISOString()} - ${req.method} ${req.path}`);
  next();
});

app.get('/', (req, res) => {
  res.send('LINE Bot Todo List is running! üìù‚úÖ');
});

// Webhook handler
app.post('/webhook', (req, res) => {
  console.log('üöÄ Webhook called!');
  res.status(200).send('OK');
  
  const events = req.body.events || [];
  console.log('üì¶ Events received:', events.length);
  
  events.forEach(async (event) => {
    if (event.type === 'message' && event.message.type === 'text') {
      await handleTextMessage(event);
    }
  });
});

async function handleTextMessage(event) {
  const userId = event.source.userId;
  const message = event.message.text.trim();
  
  console.log('üí¨ Message received:', message);
  
  try {
    // Initialize user's todo list if not exists
    if (!todoList.has(userId)) {
      todoList.set(userId, []);
    }
    
    const userTodos = todoList.get(userId);
    
    // Commands
    if (message.toLowerCase().startsWith('add ')) {
      await handleAddTodo(event, message.slice(4));
    } else if (message.toLowerCase().startsWith('done ')) {
      await handleCompleteTodo(event, message.slice(5));
    } else if (message.toLowerCase() === 'list' || message.toLowerCase() === '‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£') {
      await handleListTodos(event);
    } else if (message.toLowerCase() === 'help' || message.toLowerCase() === '‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠') {
      await handleHelp(event);
    } else if (message.toLowerCase() === 'clear' || message.toLowerCase() === '‡∏•‡πâ‡∏≤‡∏á') {
      await handleClearTodos(event);
    } else {
      await handleUnknownCommand(event);
    }
  } catch (error) {
    console.error('‚ùå Error handling message:', error);
    await client.replyMessage(event.replyToken, {
      type: 'text',
      text: '‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á'
    });
  }
}

async function handleAddTodo(event, input) {
  const userId = event.source.userId;
  const userTodos = todoList.get(userId);
  
  // Parse input: "task | time"
  const parts = input.split('|').map(part => part.trim());
  
  if (parts.length < 2) {
    await client.replyMessage(event.replyToken, {
      type: 'text',
      text: '‚ùå ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á\n\n‚úÖ ‡πÉ‡∏ä‡πâ: add ‡∏á‡∏≤‡∏ô | ‡πÄ‡∏ß‡∏•‡∏≤\nüìù ‡∏ï‡∏≠‡∏ß‡∏¢‡πà‡∏≤‡∏á: add ‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏° | 14:30\nüìù ‡∏´‡∏£‡∏∑‡∏≠: add ‡∏ó‡∏≥‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô | 25/12/2024 09:00'
    });
    return;
  }
  
  const task = parts[0];
  const timeStr = parts[1];
  
  const reminderTime = parseDateTime(timeStr);
  
  if (!reminderTime) {
    await client.replyMessage(event.replyToken, {
      type: 'text',
      text: '‚ùå ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á\n\n‚úÖ ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö:\n‚Ä¢ 14:30 (‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ)\n‚Ä¢ 25/12/2024 14:30\n‚Ä¢ 2024-12-25 14:30'
    });
    return;
  }
  
  if (reminderTime < new Date()) {
    await client.replyMessage(event.replyToken, {
      type: 'text',
      text: '‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏≠‡∏î‡∏µ‡∏ï‡πÑ‡∏î‡πâ'
    });
    return;
  }
  
  const todoId = generateId(userId);
  const todoItem = new TodoItem(todoId, userId, task, reminderTime);
  
  userTodos.push(todoItem);
  scheduleReminder(todoItem);
  
  await client.replyMessage(event.replyToken, {
    type: 'text',
    text: `‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!\n\nüìù ‡∏á‡∏≤‡∏ô: ${task}\n‚è∞ ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô: ${formatDate(reminderTime)}\nüÜî ID: ${todoId}\n\nüí° ‡∏û‡∏¥‡∏°‡∏û‡πå "list" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î`
  });
}

async function handleCompleteTodo(event, todoId) {
  const userId = event.source.userId;
  const userTodos = todoList.get(userId);
  
  const todoIndex = userTodos.findIndex(todo => todo.id === todoId && !todo.completed);
  
  if (todoIndex === -1) {
    await client.replyMessage(event.replyToken, {
      type: 'text',
      text: '‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢\n\nüí° ‡∏û‡∏¥‡∏°‡∏û‡πå "list" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç ID ‡∏Ç‡∏≠‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î'
    });
    return;
  }
  
  const todoItem = userTodos[todoIndex];
  todoItem.completed = true;
  
  // Cancel scheduled reminder
  const job = scheduledJobs.get(todoId);
  if (job) {
    job.cancel();
    scheduledJobs.delete(todoId);
  }
  
  // Remove from active list
  userTodos.splice(todoIndex, 1);
  
  await client.replyMessage(event.replyToken, {
    type: 'text',
    text: `üéâ ‡∏ó‡∏≥‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏ß‡πâ‡∏ß‡∏ß‡∏ß‡∏ß! -3- \n\nüìù ‡∏á‡∏≤‡∏ô: ${todoItem.task}\n‚úÖ ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏™‡∏£‡πá‡∏à‡πÄ‡∏°‡∏∑‡πà‡∏≠: ${formatDate(new Date())}`
  });
}

async function handleListTodos(event) {
  const userId = event.source.userId;
  const userTodos = todoList.get(userId);
  
  if (userTodos.length === 0) {
    await client.replyMessage(event.replyToken, {
      type: 'text',
      text: 'üìã ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Todo\n\nüí° ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà‡∏î‡πâ‡∏ß‡∏¢: add ‡∏á‡∏≤‡∏ô | ‡πÄ‡∏ß‡∏•‡∏≤ ‡πÑ‡∏î‡πâ‡πà‡πÄ‡∏•‡∏¢‡∏à‡πâ‡∏≤ -3-'
    });
    return;
  }
  
  let listText = 'üìã ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ Todo ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì -3-:\n\n';
  userTodos.forEach((todo) => {
    listText += `${todo.id}. üìù ${todo.task}\n`;
    listText += `   ‚è∞ ${formatDate(todo.reminderTime)}\n\n`;
  });
  
  listText += 'üí° ‡∏û‡∏¥‡∏°‡∏û‡πå "done <‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç>" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏™‡∏£‡πá‡∏à -3-';
  
  await client.replyMessage(event.replyToken, {
    type: 'text',
    text: listText
  });
}

async function handleHelp(event) {
  const helpText = `ü§ñ LINE Bot Todo List\n\nüìù ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡πÑ‡∏î‡πâ:\n\n‚Ä¢ add ‡∏á‡∏≤‡∏ô | ‡πÄ‡∏ß‡∏•‡∏≤\n  ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÉ‡∏´‡∏°‡πà\n  ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á: add ‡∏õ‡∏£‡∏∞‡∏ä‡∏∏‡∏° | 14:30\n\n‚Ä¢ list ‡∏´‡∏£‡∏∑‡∏≠ ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n  ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î\n\n‚Ä¢ done <‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç>\n  ‡∏ó‡∏≥‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏´‡∏°‡∏≤‡∏¢‡∏ß‡πà‡∏≤‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß\n\n‚Ä¢ clear ‡∏´‡∏£‡∏∑‡∏≠ ‡∏•‡πâ‡∏≤‡∏á\n  ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î\n\n‚Ä¢ help ‡∏´‡∏£‡∏∑‡∏≠ ‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠\n  ‡πÅ‡∏™‡∏î‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î\n\n‚è∞ ‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡πÄ‡∏ß‡∏•‡∏≤:\n‚Ä¢ 14:30 (‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ)\n‚Ä¢ 25/12/2024 14:30\n‚Ä¢ 2024-12-25 14:30`;
  
  await client.replyMessage(event.replyToken, {
    type: 'text',
    text: helpText
  });
}

async function handleClearTodos(event) {
  const userId = event.source.userId;
  const userTodos = todoList.get(userId);
  
  // Cancel all scheduled jobs
  userTodos.forEach(todo => {
    const job = scheduledJobs.get(todo.id);
    if (job) {
      job.cancel();
      scheduledJobs.delete(todo.id);
    }
  });
  
  // Clear todo list
  todoList.set(userId, []);
  
  await client.replyMessage(event.replyToken, {
    type: 'text',
    text: 'üóëÔ∏è ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢!'
  });
}

async function handleUnknownCommand(event) {
  await client.replyMessage(event.replyToken, {
    type: 'text',
    text: '‡∏´‡∏ô‡∏π‡πÑ‡∏°‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ‡∏á‡∏á -3-\n\nüí° ‡∏û‡∏¥‡∏°‡∏û‡πå "help" ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î'
  });
}

// Error handling middleware
app.use((error, req, res, next) => {
  console.error('üí• Error occurred:', error);
  
  if (error instanceof line.SignatureValidationFailed) {
    console.error('‚ùå Signature validation failed');
    res.status(401).send('Signature validation failed');
  } else if (error instanceof line.JSONParseError) {
    console.error('‚ùå JSON parse error');
    res.status(400).send('JSON parse error');
  } else {
    res.status(500).send('Internal Server Error');
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`üöÄ Server is running on port ${PORT}`);
  console.log(`üåê Webhook URL: http://localhost:${PORT}/webhook`);
  console.log('üìã Make sure your .env file contains:');
  console.log('   CHANNEL_ACCESS_TOKEN=your_channel_access_token');
  console.log('   CHANNEL_SECRET=your_channel_secret');
  console.log('');
  console.log('ü§ñ LINE Bot Todo List Features:');
  console.log('   ‚úÖ Add todos with reminders');
  console.log('   ‚è∞ Schedule notifications');
  console.log('   üìù List all todos');
  console.log('   üéâ Mark todos as done');
  console.log('   üóëÔ∏è Clear all todos');
});